# **Fabric Data: Secured-By-Design** 



## The Logical Unit 

Most database management systems store data in silos, based on the type of data being stored (e.g. customer data, financial data, address data, device data). When data is needed, hundreds or thousands of tables may need to be queried using complex joins to deliver the information. The process is very cumbersome, complex and time consuming.  

Fabric organizes and stores data very differently all together. By storing data based on the needs of the business and not on a pre-defined structure, enterprises can improve the speed, agility and with security of their data. 

Any business-related entity (a customer, a product, a service, etc.) can be represented by a Logical Unit. A Logical Unit is associated with a schema that defines all the relevant pieces of data associated with the defined business entity. That schema reflects a business-oriented structure (Logical Unit) containing relevant data from every table and object from every system (e.g., 100 tables from the CRM system running MySQL with 200 tables from the billing system residing on Oracle).



## Logical Unit Encryption 

Fabric encrypts each Logical Unit Instance (LUI) using a AES256 algorithm in OFB mode and creates a unique encryption for each LUI. The LUI data is only readable using the master key which is also always encrypted. 

This additional atomic-level encryption delivers greater protection for sensitive data and eliminates the chance of a large-scale data breach.



## Fabric Hashing Mechanism

Data related to Fabric The Fabric Masking mechanism uses the SHA-256 algorithm for hashing data. 

For example:

- An Instance Key used to encrypt LU Instances is the hashed combination of the LU name, LU Instance, and the master key.
- Fabric masking utility uses the SHA-256 algorithm when hashing the original value of any encrypted field (such as interface passwords etc ...).

<img src="/articles/26_fabric_security/images/01_hashing_data.PNG">



## Fabric Project Encryption

The following illustration shows how Logical Units Instances inherit their own private encryption key based on Fabric master key and the LU they belon to.

<img src="/articles/26_fabric_security/images/02_fabric_encryption_process.png">

### Fabric Master Key 

#### Master Key Generation

Fabric generates its master key using Java built-in methods for AES-256 with GCM (Galois/Counter Mode) keys generation. 
The master key is generated by Fabric, using the manual Fabric command, and is encrypted using the protection key. 

Once The new generated Master Key is broken into bytes. Each byte is stored in a separate record in the dedicated Cassandra table. 
Using Cassandra distribution data logic, the parts of the key are stored across different nodes. 
Access to the dedicated Cassandra table is enabled only through K2View Fabric, while regular access through Cassandra has been disabled.

The master key is encrypted using the protection key:
- JAVA_AES library generates a new key using an AES-256 algorithm. 
- The generated key size is 256 bit. 
- The key generation is based on secured random generation.
- Fabric uses ARS256 algorithm to encrypt the master key.


#### Master Key Storage

Fabric supports a generation of master key with or without the keystore mechanism. 

**w/ keystore**
If you want to use a keystore to hold the protection key of the master key, set the ```MASTERKEY_KEY_STORE_ENABLED``` parameter of your config.ini file to ```true```.

**w/o keystore**
Fabric enables a generation of a master key even if no keystore is installed on your Fabric. A new protection key is generated for each master key. 
When Fabric starts for the first time, a default master key is generated.

A keystore can be added later and the master key will be re-generated using the protection key of the keystore. 
Please note that once the keystore is added to Fabric, it cannot be removed


#### Protection Key Storage

Fabric setup must use Java keytool to create a keystore, which contains an AES-256 key. This is the protection key.
The keystore is locked by a password and is copied to each node of the Fabric cluster.
When starting Fabric, the user must key-in the password of the keystore otherwise Fabric cannot start.

When a new master key is generated, the master key store opens the keystore, gets the protection key stored in the keystore, and uses it with an initialization vector (IV) to encrypt the master key of Fabric. 
The keystore contains the history of all encryptions. Each encryption of a master key creates a record in the keystore with the protection key and the key description of the encrypted master key. This way, when users change the protection key in the keystore, the old protection key can still be used to get entities already encrypted with the previous protection key. 

#### Keys in Cassandra

Keys are stored in the KEYS table in the K2AUTH keyspace. This table contains the key description, index, and value fields.
By using Cassandra distribution data logic, each node stores only part of the Master Key. The access to the KEYS table is enabled only through K2View Fabric and is disabled through regular access to Cassandra. 
The fact that the master key is stored in a dedicated Cassandra table, enables adding/removing nodes without impacting the solution, because each byte of the key is duplicated into several nodes (number of nodes depends on the replication factor of the Fabric cluster).



### Master Key Commands

The key is generated from Performed by using Fabric command - activate key. The activate key command activates 2 components:
o	Key generator
o	Master key store

A key is generated by using the following command:
```activatekey name='<name>' [generatorType='<generatorType>'] [storeType='<storeType>'] [WITH ARGS='<args>']```

e.g.
```activatekey name='keyProjectX' [generatorType='Java_AES'] [storeType='Stripe_AES']```


### Master Key Rotation

Master key rotation enables generating and activating a new master key. The new master key impacts instance IDs saved in Cassandra from the moment it was generated onwards. The already existing instance IDs are not impacted by the new key, until they are next sync-ed and saved on Cassandra.

Upon retrieval of a specific instance ID, K2View Fabric collects the information of the Master Key that was used for the encryption of the LU instance and performs on the fly the de-encryption of the data.



## LUI Encryption

### LUI Encryption Key
Fabric encrypts each instance (LUI) using the AES-256 in OFB mode encryption algorithm. Hence, the key length is 256 bytes. If an input key is shorter than the maximum key length, the key content is repeated as many times as necessary to complete the key.

The underlying key will be the hash (using SHA-256 algorithm) of the following parts:

- LU type name (logical unit name). For example: “CUSTOMER”
- LUI (instance id). For example: “123”
- Master key- input key generated as detailed in the previous section of this document.

As a result, Fabric creates a different key for each instance id, because each instance id has a different value. Fabric saves the key description for each instance id (in the ENTITY table in cassandra). This way, Fabric can decrypt the entity when necessary.
The encrypted master key that was used to encrypt the instance id, can be taken from the KEYS table by the key description.

### Encrypt LUI Using Fabric Studio

By default, when creating a logical unit, the *enable data encryption* property field is set to ‘False’.

If you wish to encrypt each instance (LUI), set the ‘Enable data encryption’ property of your LU schema to ‘True’. 

See the screenshot below:

<img src="/articles/26_fabric_security/images/03_fabric_LUencryption_studio.PNG">


### LUI Partial Encryption

If you wish to encrypt only selected fields on the LU instance, you need first to set the following parameter to false in the config.ini file ```FULL_ENTITY_ENCRYPTION=false```.

It is then possible to encrypt specific fields in your implementation using the following built-in functions:

<img src="/articles/26_fabric_security/images/04_fabric_LUencryption_LUEncrypt.png">


**luEncrypt()**

```public static String luEncrypt(String plainData) throws Exception```

The function encrypts data in text format using the latest master key and LUI key. This method can be used to encrypt individual fields in the LUI micro-database

Parameters:

- plainData - the text to encrypt


The function returns the following:

- Data encrypted with the LUI key described above.


**luDecrypt()**

```public static String luDecrypt(String encryptedData, String luName, String entityID) throws Exception```

The function decrypts a string that was previously encrypted using the ```luEncrypt``` method:

Parameters:

- encryptedData - the encrypted data
- luName - The LUType for the data to decrypt
- entityID - The instance id of the instance holding this data


The function returns the following:

- Decrypted text
- Exception in cases when decryption failed



**luRekey()** 

```public static String luRekey(String encryptedData) throws Exception```

The function decrypts data with it's key and encrypts it with the latest master key. For a system to support the rekey option, data needs to be re-keyed when re-syncing the LUI.

Parameters:

encryptedData - Encrypted data to be rekeyed


The function returns the following:

- Encrypted data, encrypted with the active key
- Exception in cases when the process has failed





[<img align="right" width="60" height="54" src="/articles/images/Next.png">](/articles/20_jobs_and_batch_services/02_jobs_flow_and_status.md) 
